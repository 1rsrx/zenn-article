---
title: "async/awaitã§é€šä¿¡ä¸­ã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã"
emoji: "ğŸ¾"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["swift"]
published: true
---

# ã¯ã˜ã‚ã«
async/awaitã®ç™»å ´ã«ã‚ˆã‚Šã€éåŒæœŸå‡¦ç†ã‚’åŒæœŸå‡¦ç†ã®ã‚ˆã†ã«æ›¸ã‘ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚
ãã®ç‚¹ã¯ã™ã”ãä¾¿åˆ©ãªã®ã§ã™ãŒã€æ¬¡ã®è¡Œã«é€²ã‚“ã æ™‚ç‚¹ã§ã€éåŒæœŸå‡¦ç†å‡¦ç†ãŒçµ‚äº†ã—ã¦ã„ã‚‹ã®ã§ã€
å‡¦ç†ä¸­ã®ãƒ†ã‚¹ãƒˆãŒæ›¸ã‘ãšã«ã„ã¾ã—ãŸã€‚
ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’ä½¿ã†ã“ã¨ã§ã€è§£æ±ºã§ããŸã®ã§ãã®æ–¹æ³•ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚

æº–å‚™éƒ¨åˆ†ãŒé•·ã„ã®ã§çµè«–ãŒè¦‹ãŸã„æ–¹ã¯ã€`ãƒ†ã‚¹ãƒˆã‚’æ›¸ã`ã¾ã§ã‚¸ãƒ£ãƒ³ãƒ—ã—ã¦ãã ã•ã„ã€‚

# å¯¾è±¡è€…
- ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆãŒåˆ†ã‹ã‚‹äºº
- async/awaitã®æ›¸ãæ–¹ãŒåˆ†ã‹ã‚‹äºº

# ã‚µãƒ³ãƒ—ãƒ«ã‚¢ãƒ—ãƒªã®æº–å‚™
[ãƒªãƒã‚¸ãƒˆãƒª](https://github.com/HikaruKurodq/ConcurrencyMVVMSample)
è©³ç´°ã¯çœç•¥ã—ã¾ã™ãŒã€GitHubã®ãƒªãƒã‚¸ãƒˆãƒªã‚’æ¤œç´¢ã™ã‚‹ã‚ˆãã‚ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã‚¢ãƒ—ãƒªã‚’å©ãå°ã«ã—ã¾ã™ã€‚


# æº–å‚™
## ViewModelã®ä½œæˆ
```swift
@MainActor
class SearchRepositoryViewModel {

    private var model: SearchRepositoryModelable

    // Output
    @Published var errorMessage = ""
    @Published var repositories = [Repository]()
    @Published var isLoading = false

    private var searchText = ""

    init(model: SearchRepositoryModelable) {
        self.model = model
    }
}

// Input
extension SearchRepositoryViewModel {
    func onSearchTextChanged(_ text: String) {
        self.searchText = text
    }

    func onSearchButtonTapped() async {
        if isLoading {
            return
        }

        isLoading = true
        defer {
            isLoading = false
        }

        do {
            let repositories = try await model.fetchRepositries(keyword: searchText)
            self.repositories = repositories
        } catch {
            errorMessage = error.localizedDescription
        }

    }
}
```

@Publishedã‚’ã¤ã‘ã¦ãŠãã¨ã€Publisherã¨ã—ã¦å–ã‚Šå‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚
(ä¾‹)
`viewModel.$isLoading.sink { }`

## Modelã®ä½œæˆ
```swift
protocol SearchRepositoryModelable {
    func fetchRepositries(keyword: String) async throws -> [Repository]
}

class SearchRepositoryModel: SearchRepositoryModelable {

    private let baseURL = "https://api.github.com/search/repositories"

    func fetchRepositries(keyword: String) async throws -> [Repository] {
        let urlString = self.baseURL + "?q=\(keyword)"
        guard let url = URL(string: urlString) else {
            throw GitHubAPIError.invailedURL
        }
        let request = URLRequest(url: url)

        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
            let httpResponse = response as! HTTPURLResponse
            if httpResponse.statusCode != 200 {
                throw GitHubAPIError.any
            }

            // ãƒ‡ã‚³ãƒ¼ãƒ‰
            let decoder = JSONDecoder()
            do {
                let result = try decoder.decode(
                    GitHubAPIGetRepositoriesResult.self,
                    from: data
                )

                return result.items
            } catch {
                throw GitHubAPIError.parse
            }
        } catch {
            throw GitHubAPIError.any
        }
    }
}
```

## Modelã‚’Mockã™ã‚‹
```swift
class MockSearchRepositoryModel: SearchRepositoryModelable {
    func fetchRepositries(keyword: String) async -> [SearchRepositoryApp.Repository] {
        return []
    }
}
```

## ãƒ†ã‚¹ãƒˆã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‹
```swift
@MainActor
final class SearchRepositoryViewModelTests: XCTestCase {

    private var viewModel: SearchRepositoryViewModel!
    private var model: MockSearchRepositoryModel!

    override func setUpWithError() throws {
        model = MockSearchRepositoryModel()
        viewModel = SearchRepositoryViewModel(model: model)
    }

    override func tearDownWithError() throws {
    }

    // ã“ã®é–¢æ•°ã®ä¸­ã«æ›¸ã„ã¦ã„ã
    func testOnSearchButtonClicked() async throws {
    }
}
```

## ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
é€šä¿¡ä¸­ã®ãƒ†ã‚¹ãƒˆãŒæ›¸ããŸã„ã®ã§ã€ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã¯ä¸‹è¨˜ã§ã™ã€
- é€šä¿¡å‰ã¯ã€isLoadingãŒfalseã§ã‚ã‚‹ã“ã¨
- é€šä¿¡ä¸­ã¯ã€isLoadingãŒtrueã§ã‚ã‚‹ã“ã¨
- é€šä¿¡å¾Œã¯ã€isLoadingãŒfalseã§ã‚ã‚‹ã“ã¨

# ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
## çŠ¶æ³èª¬æ˜
```swift
func testOnSearchButtonClicked() async throws {

    // é€šä¿¡å‰
    XCTAssertFalse(viewModel.isLoading)

    await model.fetchRepositries("")
    
    // é€šä¿¡å¾Œ
    XCTAssertFalse(viewModel.isLoading)
}
```
ã“ã®ã‚ˆã†ã«é€šä¿¡å‰å¾Œã—ã‹æ›¸ã‘ãªã„

## æ›¸ã„ã¦ã„ãï¼
ã¾ãšã€Mockã—ãŸModelã‚¯ãƒ©ã‚¹ã‚’æ›¸ãæ›ãˆã¾ã™ã€‚
```swift
class MockSearchRepositoryModel: SearchRepositoryModelable {
    var onFetchRepositoriesCalled: (() -> Void)?
    var fetchRepositoriesResult: [Repository]!

    func fetchRepositries(keyword: String) async throws -> [SearchRepositoryApp.Repository] {
        onFetchRepositoriesCalled?()

        return await withCheckedContinuation {
            $0.resume(returning: fetchRepositoriesResult)
        }
    }
}
```

`withCheckedContinuation`ã‚’ä½¿ã†ã¨ä»»æ„ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å®Œäº†é€šçŸ¥ã‚’æŠ•ã’ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã§æ›¸ã‹ã‚ŒãŸé–¢æ•°ã‚’Concurrencyå¯¾å¿œã•ã›ã‚‹æ™‚ã«ä½¿ã‚ã‚Œã¾ã™ã­ã€‚

å®Œäº†é€šçŸ¥ã‚’æŠ•ã’ã‚‹å‰ã«ã€å¤–éƒ¨ã‹ã‚‰å—ã‘å–ã£ãŸã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ã‚’å®Ÿè¡Œã—ã€
ãã“ã§é€šä¿¡ä¸­ã®ãƒ†ã‚¹ãƒˆã‚’è¡Œã„ã¾ã™ã€‚

```swift
func testOnSearchButtonClicked() async throws {
    // åˆæœŸå€¤
    XCTAssertFalse(viewModel.isLoading)

    // é€šä¿¡ä¸­
    model.onFetchRepositoriesCalled = {
        XCTAssertTrue(self.viewModel.isLoading)
    }
    model.fetchRepositoriesResult = []

    await viewModel.onSearchButtonTapped()

    // é€šä¿¡å¾Œ
    XCTAssertFalse(self.viewModel.isLoading)
}
```

è‰²ã€…è©¦è¡ŒéŒ¯èª¤ã—ã¾ã—ãŸãŒã€ã‚µã‚¯ãƒƒã¨æ›¸ãã“ã¨ãŒã§ãã¾ã—ãŸã€‚