---
title: "今更ながらAPIクライアントを自作してみる"
emoji: "👒"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["swift"]
published: true
---

# APIクライアントの仕様
- 通信結果はResult型にして返す
- Requestクラスでエンドポイント, header部, Body部を指定できる
- ライブラリは使用しない

# 実装

## 1. Requestクラスの作成

### 1-1 Httpメソッドのenumを用意
```swift
enum HttpMethod: String {
    case get = "GET"
    case post = "POST"
    case put = "PUT"
    case delete = "DELETE"
    case patch = "PATCH"
}
```
### 1-2 エラー用のenumを用意
```swift
enum ApiError: Error {
    case url // URLが無効
    
    // 通信失敗
    case network // ネットワークに繋がっていない
    case response // それ以外

    // レスポンス取得後
    case emptyResponse // レスポンスが空
    case parse // JSONのエンコードに失敗
    case errorResponse(status: Int, data: Decodable) // その他（レスポンスがデコードできた場合）
    case error(status: Int, data: Data) // その他（レスポンスがデコードできない場合）
}
```

### 1-3 Header用のクラスを用意
```swift
class HttpHeader {
    private var header: [String: String]
    
    init(_ header: [String: String]) {
        self.header = header
    }
    
    func addValues(_ values: [String: String]) -> HttpHeader {
        var header = self.header
        
        values.forEach { (key, value) in
            header[key] = value
        }

        return HttpHeader(header)
    }
    
    func values() -> [String:String] {
        return self.header
    }
}
```
[String:String]のヘッダーに値を追加するために作りました。
Dictionaryを拡張しても良かったのですが、スコープが大きいので避けました。

### 1-4 Protocolの用意
```swift
protocol HttpRequestable {
    associatedtype Response: Decodable
    associatedtype ErrorResponse: Decodable
    
    var baseURL: String { get }
    var path: String { get }
    var method: HttpMethod { get }
    var header: HttpHeader { get }
    var httpBody: Encodable? { get }
}
```

### 1-5 空レスポンス用の構造体を用意
```swift
struct EmptyResponse: Codable {}
```
QiitaAPIを叩き台にして動作確認を行ったところ、DELETEメソッドの成功時、空のレスポンスが返ってくるためデコードエラーになりました。空レスポンスでも、ステータスコードで結果が判断できる時はこちらをResponseに指定します。


## 2. 通信を行うクラス作成する
### 2-1 コールバック版の実装
```swift
class ApiClient {
    
    func request<T: HttpRequestable>(
        _ request: T,
        completion: @escaping ((Result<T.Response, ApiError>) -> Void)
    ) {
        guard let url = URL(string: request.baseURL + request.path) else {
            completion(Result<T.Response, ApiError>.failure(.url))
            return
        }
        
        // ヘッダー, HTTPメソッドの設定
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = request.method.rawValue
        urlRequest.allHTTPHeaderFields = request.header.values()
        
        // ボディー部があれば設定
        if let httpBody = request.httpBody,
        let bodyData = try? JSONEncoder().encode(httpBody) {
            urlRequest.httpBody = bodyData
        }
        
        print("start \(urlRequest.httpMethod ?? "") \(urlRequest.url?.absoluteString ?? "")")
        let task = URLSession.shared.dataTask(with: urlRequest) { data, response, err in
            if let err = err {
                // ネットワークエラー
                if let _ = err as? URLError {
                    completion(Result<T.Response, ApiError>.failure(.network))
                    return
                }
                
                completion(Result<T.Response, ApiError>.failure(.response))
                return
            }

            guard let response = response as? HTTPURLResponse,
                  let data = data else {
                 // data, responseが空の場合
                completion(Result<T.Response, ApiError>.failure(.emptyResponse))
                return
            }
            
            // ログ
            let statusCode = response.statusCode
            print("ステーテスコード: \(statusCode)")
            if let json = try? JSONSerialization.jsonObject(with: data) {
                print("レスポンス: \(json)")
            }
            
            if (200...299).contains(statusCode) {
                // 成功
                do {
                    let object = try JSONDecoder().decode(T.Response.self, from: data)
                    completion(Result<T.Response, ApiError>.success(object))
                } catch {
                    // 空レスポンスが成功の場合
                    if String(data: data, encoding: .utf8) == "" {
                        if let emptyResponse = EmptyResponse() as? T.Response {
                            completion(Result<T.Response, ApiError>.success(emptyResponse))
                            return
                        }
                    }

                    // デコードエラー
                    completion(Result<T.Response, ApiError>.failure(.parse))
                }
            } else {
                // 失敗
                do {
                    // レスポンスをデコードできた場合
                    let object = try JSONDecoder().decode(T.ErrorResponse.self, from: data)
                    completion(Result<T.Response, ApiError>.failure(.errorResponse(status: statusCode, data: object)))
                } catch {
                    // レスポンスをデコードできなかった場合
                    completion(Result<T.Response, ApiError>.failure(.error(status: statusCode, data: data)))
                }
            }
        }
        
        task.resume()
    }
}
```

説明はコメントに書きました。

### 2-2 Combine, Concurrency対応
```swift
func request<T: HttpRequestable>(
    _ request: T
) -> AnyPublisher<Result<T.Response, ApiError>, Never> {
    return Future { promise in
        self.request(request) { result in
            promise(.success(result))
        }
    }
    .eraseToAnyPublisher()
}

func request<T: HttpRequestable>(
    _ request: T
) async -> Result<T.Response, ApiError> {
    return await withCheckedContinuation { continuation in
        self.request(request) { result in
            return continuation.resume(returning: result)
        }
    }
}
```

コールバック版をラップする形で実装しました。
プロジェクトで1つに統一する場合は、コールバック版をprivateにするなり、いい感じに書き換えてくださいｗ

## 3 Requestの作成
```swift
class QiitaApiPostArticle {
    func execute(
        article: QiitaApiPostArticleRequestJSON,
        completion: @escaping ((Result<QiitaApiPostArticleResponseJSON, ApiError>) -> Void)
    ) {
        let request = QiitaApiPostArticleRequest(httpBody: article)
        ApiClient().request(request, completion: completion)
    }
}

struct QiitaApiPostArticleRequest: HttpRequestable {
    typealias Response = QiitaApiPostArticleResponseJSON
    typealias ErrorResponse = QiitaApiErrorResponse
    
    var baseURL: String {
        return AppConstant.Api.qiitaBaseURL
    }
    
    var path: String {
        return "items/"
    }
    
    var method: HttpMethod {
        return .post
    }
    
    var header: HttpHeader {
        return HttpHeader(ApiHeaderConstant.qiita)

        // 定数ヘッダーに値を追加するには下記のようにします。
        return HttpHeader(ApiHeaderConstant.qiita)
            .addValues([:])
            .addValues([:])
    }
    
    var httpBody: Encodable?
}
```

## 呼び出してみる
### コールバック版
```swift
let article = QiitaApiPostArticleRequestJSON(
            body: "本文",
            private: true,
            tags: [
                .init(name: "swift", versions: ["0.0.1"])
            ],
            title: "title",
            tweet: false
        )
let api = QiitaApiPostArticle()
api.execute(article: article) { result in
    switch result {
    case .success(let response):
        self.showAlert(title: "成功", message: "\(response)")
    case .failure(let err):
        self.showAlert(title: "失敗", message: "\(err)")
    }
}
```

### Combine版
```swift
let api = QiitaApiGetUserProfile()
api.execute()
    .sink { result in
        switch result {
        case .success(let response):
            self.showAlert(title: "成功", message: "\(response)")
        case .failure(let err):
            self.showAlert(title: "失敗", message: "\(err)")
        }
    }
    .store(in: &cancellables)
```

### Concurrency版
```swift
let api = QiitaApiDeleteArticle()
Task {
    let result = await api.execute(itemID: "e3766591a506755a2d8d")
    
    switch result {
    case .success(let response):
        self.showAlert(title: "成功", message: "\(response)")
    case .failure(let err):
        self.showAlert(title: "失敗", message: "\(err)")
    }
}
```

## 最後に
https://github.com/HikaruKurodq/ApiClientTest
こちらのプロジェクトで動作確認できます。

マサカリ歓迎なので、考慮不足な箇所や間違っている箇所があれば、教えていただけると嬉しいです。